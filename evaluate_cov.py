import glob
import os 
from posebusters import PoseBusters
from pathlib import Path
import pandas as pd

# use posebusters conda env
def make_eval_df(true_poses, pred_poses, pose_bust_cols):
    '''
    performs posebusters tests on predicted poses of all proteins 
    true_poses (str): path to ground truth poses 
    pred_poses(str): path to predicted poses
    pose_bust_cols(list): column names of pose busters output to make final df

    all_pose_evals: returns a DataFrame with the posebusters output for each predicted pose for each protein
    '''
    # import ipdb; ipdb.set_trace()
    all_pose_evals = pd.DataFrame(columns=pose_bust_cols)
    for prot in glob.glob(f"{true_poses}/**/*.pdb", recursive=True):
        prot_path_split = prot.split('/') # protein file path dir list
        complex_name = prot_path_split[-1].split('_')[0] # pdb code 
        print(complex_name)

        true_lig = f'{true_poses}/{complex_name}/{complex_name}_ligand.sdf'
        poses = glob.glob(f"{pred_poses}/{complex_name}/*.sdf")

        rank1_file = [pose for pose in poses if 'rank1.sdf' in pose]
        if len(poses) < 10: # to filter out failed sampling attempts 
            print(f'not all poses were predicted for {complex_name}, moving to next')
        else:
            poses.remove(rank1_file[0]) # removing duplicate rank1 pose
            dfs = []
            for pose in poses: 
                
                buster = PoseBusters(config="redock")
                buster_current = buster.bust(pose, true_lig, prot, full_report=True)

                df_buster_reset = buster_current.reset_index() # changing file and molecule to columns instead of indexes
                file = df_buster_reset.iloc[0, df_buster_reset.columns.get_loc('file')]
                rank_num = file.split('/')[-1].split('_')[0]
                # adding complex and pose rank to df 
                df_buster_reset.at[0, 'molecule'] = f'{complex_name}_{rank_num}'
                dfs.append(df_buster_reset)

            all_pose_evals = pd.concat([all_pose_evals] + dfs, ignore_index=True)
    return all_pose_evals

def score_model_eval(all_pose_buster_df, num_gen=10, rmsd_check=2):
    '''
    assesses the performance of poses generated by DiffDock-L's score model (not ranking by confidence model)
    input: 
        all_pose_buster_df (DataFrame): output from make_eval_df made using PoseBusters 
        rmsd_check (float): Å RMSD threshold check. Default: 2
        num_gen (int): number of poses generated for a ligand. Default: 10
    output: 
        best_rmsd_perc (int): % of lowest rmsd poses that have rmsd less than threshold 
        mean_rmsd_perc (int): % of mean rmsd's of all generated poses that have rmsd less than threshold 
        metrics_df (DataFrame): assessment metrics for each protein 
    '''
    all_pose_buster_df['protein'] = all_pose_buster_df['molecule'].str.extract(r'^(.*?)_') 
    all_pose_buster_df['rank'] = all_pose_buster_df['molecule'].str.extract(r'rank(\d+)').astype(int)
    # sort within proteins based on rmsd of poses generated NOT by rank predicted
    sorted_df = all_pose_buster_df.groupby('protein', group_keys=False).apply(lambda group: group.sort_values('rmsd'))
    group_df = sorted_df.groupby('protein')

    num_prots= len(group_df.groups)

    # initializing values/df
    columns = ['Protein', 'Best RMSD', 'Mean RMSD', 'Std Dev of RMSD', 'RMSD < 2 %']
    metrics_df = pd.DataFrame(columns=columns)
    count_best_poses = 0 # counting lowest rmsd sampled poses that have RMSD < 2A 
    count_mean = 0 # for mean count 
    for prot, row_index in group_df.groups.items(): 
        # best rmsd
        rmsd_best = sorted_df.loc[row_index[0], 'rmsd']
        count_best_poses += (rmsd_best < rmsd_check)

        # mean rmsd assessment 
        group_rmsd = group_df.get_group(prot)
        mean_rmsd = group_rmsd['rmsd'].mean()
        count_mean += (mean_rmsd < rmsd_check)

        # spread of RMSDs
        std_rmsd = group_rmsd['rmsd'].std()

        # % of poses that has < 2 RMSD
        count_poses = 0
        for index in row_index: 
            rmsd_value = sorted_df.loc[index, 'rmsd']
            count_poses += (rmsd_value < rmsd_check)
        rmsd_per_prot = count_poses/num_gen * 100 

        # update metrics
        metrics_df = pd.concat([metrics_df, pd.DataFrame({'Protein': [prot],
        'Best RMSD': [rmsd_best],
        'Mean RMSD': [mean_rmsd],
        'Std Dev of RMSD': [std_rmsd],
        'RMSD < 2 %': [rmsd_per_prot], })], ignore_index=True)

        mean_rmsd_perc = count_mean / num_prots *100

        best_gen_perc = count_best_poses/num_prots * 100

    return mean_rmsd_perc, best_gen_perc, metrics_df

def confidence_model_eval(all_pose_buster_df, num_gen=10, rmsd_check=2):
    '''
    assesses the performance of poses ranked by DiffDock-L's confidence model
    input: 
        all_pose_buster_df (DataFrame): output from make_eval_df made using PoseBusters 
        rmsd_check (float): Å RMSD threshold check. Default: 2
        num_gen (int): number of poses generated for a ligand
    output: 
        top_pose: % of times when the top ranked pose had the lowest rmsd amongst all sampled poses 
        top_10: 
        top_50 :
    '''
    # best pose 
    count_rank1 = 0 

    all_df['protein'] = all_df['molecule'].str.extract(r'^(.*?)_') 
    all_df['rank'] = all_df['molecule'].str.extract(r'rank(\d+)').astype(int)

    sorted_df = all_df.groupby('protein', group_keys=False).apply(lambda group: group.sort_values('rank'))
    group_df = sorted_df.groupby('protein')

    num_prots= len(group_df.groups)

    count_rank1 = 0
    for prot, row_index in group_df.groups.items(): 
        rank1_rmsd = sorted_df.loc[row_index[0], 'rmsd']
        lowest_rmsd = (sorted_df.loc[row_index, 'rmsd']).min()
        count_rank1 += (rank1_rmsd == lowest_rmsd)

    rank1_corrects = count_rank1/num_prots * 100 

    return rank1_corrects

def main():
    pose_bust_cols = ['file',
    'molecule',
    'mol_pred_loaded',
    'mol_true_loaded',
    'mol_cond_loaded',
    'sanitization',
    'inchi_convertible',
    'all_atoms_connected',
    'molecular_formula',
    'molecular_bonds',
    'double_bond_stereochemistry',
    'tetrahedral_chirality',
    'bond_lengths',
    'bond_angles',
    'internal_steric_clash',
    'aromatic_ring_flatness',
    'double_bond_flatness',
    'internal_energy',
    'protein-ligand_maximum_distance',
    'minimum_distance_to_protein',
    'minimum_distance_to_organic_cofactors',
    'minimum_distance_to_inorganic_cofactors',
    'minimum_distance_to_waters',
    'volume_overlap_with_protein',
    'volume_overlap_with_organic_cofactors',
    'volume_overlap_with_inorganic_cofactors',
    'volume_overlap_with_waters',
    'rmsd_≤_2å',
    'passes_valence_checks',
    'passes_kekulization',
    'inchi_crystal_valid',
    'inchi_docked_valid',
    'inchi_crystal',
    'inchi_docked',
    'inchi_overall',
    'inchi_version',
    'stereochemistry_preserved',
    'hydrogens',
    'net_charge',
    'protons',
    'stereo_sp3',
    'stereo_sp3_inverted',
    'stereo_type',
    'number_bonds',
    'shortest_bond_relative_length',
    'longest_bond_relative_length',
    'number_short_outlier_bonds',
    'number_long_outlier_bonds',
    'number_angles',
    'most_extreme_relative_angle',
    'number_outlier_angles',
    'number_noncov_pairs',
    'shortest_noncovalent_relative_distance',
    'number_clashes',
    'number_valid_bonds',
    'number_valid_angles',
    'number_valid_noncov_pairs',
    'number_aromatic_rings_checked',
    'number_aromatic_rings_pass',
    'aromatic_ring_maximum_distance_from_plane',
    'number_double_bonds_checked',
    'number_double_bonds_pass',
    'double_bond_maximum_distance_from_plane',
    'ensemble_avg_energy',
    'mol_pred_energy',
    'energy_ratio',
    'smallest_distance_protein',
    'num_pairwise_clashes_protein',
    'most_extreme_ligand_atom_id_protein',
    'most_extreme_protein_atom_id_protein',
    'most_extreme_ligand_element_protein',
    'most_extreme_protein_element_protein',
    'most_extreme_ligand_vdw_protein',
    'most_extreme_protein_vdw_protein',
    'most_extreme_sum_radii_protein',
    'most_extreme_distance_protein',
    'most_extreme_sum_radii_scaled_protein',
    'most_extreme_relative_distance_protein',
    'most_extreme_clash_protein',
    'smallest_distance_organic_cofactors',
    'not_too_far_away_organic_cofactors',
    'num_pairwise_clashes_organic_cofactors',
    'most_extreme_ligand_atom_id_organic_cofactors',
    'most_extreme_protein_atom_id_organic_cofactors',
    'most_extreme_ligand_element_organic_cofactors',
    'most_extreme_protein_element_organic_cofactors',
    'most_extreme_ligand_vdw_organic_cofactors',
    'most_extreme_protein_vdw_organic_cofactors',
    'most_extreme_sum_radii_organic_cofactors',
    'most_extreme_distance_organic_cofactors',
    'most_extreme_sum_radii_scaled_organic_cofactors',
    'most_extreme_relative_distance_organic_cofactors',
    'most_extreme_clash_organic_cofactors',
    'smallest_distance_inorganic_cofactors',
    'not_too_far_away_inorganic_cofactors',
    'num_pairwise_clashes_inorganic_cofactors',
    'most_extreme_ligand_atom_id_inorganic_cofactors',
    'most_extreme_protein_atom_id_inorganic_cofactors',
    'most_extreme_ligand_element_inorganic_cofactors',
    'most_extreme_protein_element_inorganic_cofactors',
    'most_extreme_ligand_vdw_inorganic_cofactors',
    'most_extreme_protein_vdw_inorganic_cofactors',
    'most_extreme_sum_radii_inorganic_cofactors',
    'most_extreme_distance_inorganic_cofactors',
    'most_extreme_sum_radii_scaled_inorganic_cofactors',
    'most_extreme_relative_distance_inorganic_cofactors',
    'most_extreme_clash_inorganic_cofactors',
    'smallest_distance_waters',
    'not_too_far_away_waters',
    'num_pairwise_clashes_waters',
    'most_extreme_ligand_atom_id_waters',
    'most_extreme_protein_atom_id_waters',
    'most_extreme_ligand_element_waters',
    'most_extreme_protein_element_waters',
    'most_extreme_ligand_vdw_waters',
    'most_extreme_protein_vdw_waters',
    'most_extreme_sum_radii_waters',
    'most_extreme_distance_waters',
    'most_extreme_sum_radii_scaled_waters',
    'most_extreme_relative_distance_waters',
    'most_extreme_clash_waters',
    'volume_overlap_protein',
    'volume_overlap_organic_cofactors',
    'volume_overlap_inorganic_cofactors',
    'volume_overlap_waters',
    'rmsd',
    'kabsch_rmsd',
    'centroid_distance']
    true_poses = '/home/ymanasa/turbo/ymanasa/opt/DiffDockL-Cov/data/CSKDE95_datamol_af2'
    pred_poses = '/home/ymanasa/turbo/ymanasa/opt/DiffDockL-Cov/results/cskde95_inference'
    all_df = make_eval_df(true_poses, pred_poses, pose_bust_cols=pose_bust_cols)
    print(all_df.head())
    print(all_df.shape)


if __name__ == "__main__":
    main()   